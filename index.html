<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Blob Tracking</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    /* ChatGPT-ish dark theme w/ dark navy accent */
    --bg:#0F1115; --panel:#13161A; --canvas:#0E1116;
    --fg:#ECEDEE; --muted:#A1A7B3; --line:#2A2F3A;
    --accent:#1E2A44;          /* dark navy */
    --accent-press:#152034;
    --chip:#171A20; --radius:12px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--fg);font:16px/1.5 Helvetica, Arial, sans-serif}

  header{
    position:sticky;top:0;z-index:5;
    padding:10px 14px;border-bottom:1px solid var(--line);background:var(--panel);
    display:flex;align-items:center;gap:10px
  }
  h1{margin:0;font-size:18px;font-weight:600} /* semi-bold */
  #toggleControls{
    margin-left:auto;border:1px solid var(--line);background:var(--chip);
    color:var(--fg);padding:8px 10px;border-radius:var(--radius);cursor:pointer
  }
  #toggleControls:hover{background:var(--accent-press)}

  /* ---------- Layout: stage left, sticky controls right ---------- */
  #layout{
    display:grid; grid-template-columns: 1fr 390px; gap:16px; padding:12px 16px 96px;
  }
  body.controls-hidden #layout{ grid-template-columns: 1fr; }
  #sidebar{ position:sticky; top:64px; max-height: calc(100vh - 120px); overflow:auto; padding-left:4px; }
  body.controls-hidden #sidebar{ display:none; }
  @media (max-width: 980px){
    #layout{ grid-template-columns: 1fr; }
    #sidebar{ position:static; max-height:none; }
  }

  .panel{border:1px solid var(--line);border-radius:var(--radius);background:var(--panel);padding:16px;margin-bottom:12px}
  .panel .grid{display:grid;grid-template-columns:1fr;gap:14px}
  .ctl{display:flex;flex-direction:column;gap:8px}
  .ctl label{color:var(--muted);font-size:13px}
  .row-inline{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .row-inline span{color:var(--muted);font-size:13px;min-width:42px}
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;border:1px solid var(--line);background:var(--chip);color:var(--muted)}

  /* Spacing between Box / Line / Text groups */
  .group{padding-top:6px;margin-top:8px;border-top:1px dashed var(--line)}

  input[type="range"]{width:100%;accent-color:var(--accent)}
  input[type="text"], input[type="color"], select, .btn, .file-chip{ border-radius: var(--radius); }
  input[type="color"]{
    width:44px;height:36px;padding:0;border:1px solid var(--line);background:var(--chip);
    appearance:none; -webkit-appearance:none; overflow:hidden; cursor:pointer;
  }
  input[type="text"].hex, select.mode{
    flex:1;min-width:120px;padding:10px 12px;border:1px solid var(--line);
    background:var(--chip);color:var(--fg)
  }

  .checkline{display:flex;flex-wrap:wrap;gap:14px;align-items:center}
  .checkline label{display:flex;align-items:center;gap:8px;font-size:14px;color:var(--fg)}

  /* ---------- Stage (left) ---------- */
  #stage{min-width:0}
  #canvas{display:block;margin:0 auto;background:var(--canvas);border:1px solid var(--line);border-radius:var(--radius);max-width:min(1400px,98%);height:auto}
  video,#buf{display:none}

  /* centered status under canvas */
  #statusWrap{display:flex;justify-content:center;margin:12px 0 18px}
  #status{padding:8px 12px;border-radius:var(--radius);font-size:14px;border:1px solid var(--line);background:var(--chip);min-width:240px;text-align:center}

  /* Bottom bar */
  .bar{position:fixed;left:0;right:0;bottom:0;z-index:6;background:linear-gradient(180deg,rgba(15,17,21,0),rgba(15,17,21,.75)),var(--panel);border-top:1px solid var(--line);padding:10px 16px}
  .bar .wrap{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .push{flex:1}
  button,.btn{font:inherit;border:1px solid var(--line);background:var(--chip);color:var(--fg);padding:10px 12px;border-radius:var(--radius);cursor:pointer}
  button.primary{border-color:transparent;background:var(--accent);color:#fff} /* white text on primary */
  button.primary:active{background:var(--accent-press)}
  button.ghost{background:transparent}

  /* Pretty file chooser */
  .filewrap{display:flex;align-items:center;gap:10px}
  #fileInput{display:none}
  label[for="fileInput"].btn{display:inline-flex;align-items:center;gap:8px}
  .file-chip{padding:6px 10px;border:1px solid var(--line);background:var(--chip);color:var(--muted)}
</style>
</head>
<body>
<header>
  <h1>Blob Tracking</h1>
  <button id="toggleControls" title="Show/Hide controls">☰ Controls</button>
</header>

<div id="layout">
  <!-- Stage -->
  <main id="stage">
    <canvas id="canvas"></canvas>
    <video id="video" playsinline muted></video>
    <canvas id="buf"></canvas>
    <div id="statusWrap"><div id="status">Loading OpenCV.js…</div></div>
  </main>

  <!-- Controls -->
  <aside id="sidebar">
    <!-- Processing -->
    <section class="panel">
      <div class="grid">
        <!-- threshold moved above min area -->
        <div class="ctl"><label>Threshold (0–255) <span id="threshVal" class="badge">80</span></label><input type="range" id="thresh" min="30" max="255" value="80"></div>
        <div class="ctl"><label>Min Area (px) <span id="minAreaVal" class="badge">1200</span></label><input type="range" id="minArea" min="50" max="30000" value="1200"></div>
        <div class="ctl"><label>Processing Scale (%) <span id="scaleVal" class="badge">60</span></label><input type="range" id="scale" min="30" max="100" value="60"></div>
        <div class="ctl"><label>Morph Iterations <span id="morphVal" class="badge">2</span></label><input type="range" id="morph" min="0" max="5" value="2"></div>
        <div class="ctl"><label>BG Learning Rate α <span id="alphaVal" class="badge">0.05</span></label><input type="range" id="alpha" min="0" max="100" value="5"></div>
        <div class="ctl"><label>Max Track Disappeared <span id="maxDisappearVal" class="badge">25</span></label><input type="range" id="maxDisappear" min="3" max="150" value="25"></div>
        <div class="ctl"><label>Max Match Distance (px) <span id="maxDistVal" class="badge">80</span></label><input type="range" id="maxDist" min="10" max="300" value="80"></div>
        <div class="ctl"><label>Max Link Distance (px) <span id="linkDistVal" class="badge">180</span></label><input type="range" id="linkDist" min="10" max="600" value="180"></div>
        <div class="ctl"><label>Trail Length (frames) <span id="trailVal" class="badge">20</span></label><input type="range" id="trailLen" min="0" max="200" value="20"></div>
      </div>
    </section>

    <!-- Styling -->
    <section class="panel">
      <div class="grid">
        <div class="ctl group">
          <label>Box Thickness <span id="boxThickVal" class="badge">2</span></label>
          <input type="range" id="boxThick" min="1" max="8" value="2">
          <div class="row-inline"><span>Box</span><input type="color" id="colBox"><input id="hexBox" class="hex" value="#FF0000"></div>
          <div class="row-inline"><span>Opacity</span><input type="range" id="boxAlpha" min="10" max="100" value="100" style="flex:1"><span id="boxAlphaVal" class="badge">100%</span></div>
        </div>

        <div class="ctl group">
          <label>Line Width <span id="lineWidthVal" class="badge">2</span></label>
          <input type="range" id="lineWidth" min="1" max="8" value="2">
          <div class="row-inline"><span>Line</span><input type="color" id="colLine"><input id="hexLine" class="hex" value="#FF0000"></div>
          <div class="row-inline"><span>Opacity</span><input type="range" id="lineAlpha" min="10" max="100" value="100" style="flex:1"><span id="lineAlphaVal" class="badge">100%</span></div>
        </div>

        <div class="ctl group">
          <label>Text</label>
          <div class="row-inline" style="width:100%">
            <span style="min-width:auto">Size</span>
            <input type="range" id="textSize" min="8" max="48" value="14" style="flex:1">
            <span id="textSizeVal" class="badge">14</span>
          </div>
          <div class="row-inline"><span>Color</span><input type="color" id="colText"><input id="hexText" class="hex" value="#EEEEEE"></div>
          <div class="row-inline"><span>Opacity</span><input type="range" id="textAlpha" min="10" max="100" value="100" style="flex:1"><span id="textAlphaVal" class="badge">100%</span></div>
          <div class="row-inline">
            <span>Text Mode</span>
            <select id="textMode" class="mode">
              <option value="coords" selected>Coordinates</option>
              <option value="text">Custom Text</option>
            </select>
          </div>
          <input id="labelText" class="hex" placeholder="text" value="fern" disabled>
        </div>
      </div>
    </section>

    <!-- Visibility -->
    <section class="panel">
      <div class="grid">
        <div class="ctl">
          <label>Visibility</label>
          <div class="checkline">
            <label><input type="checkbox" id="showBoxes" checked> Show Boxes</label>
            <label><input type="checkbox" id="showTrail" checked> Show Trails</label>
            <label><input type="checkbox" id="showLinks" checked> Show Links</label>
            <label><input type="checkbox" id="showPoints"> Show Points</label>
            <label><input type="checkbox" id="showText" checked> Show Text</label>
          </div>
        </div>
      </div>
    </section>
  </aside>
</div>

<!-- Bottom bar -->
<div class="bar">
  <div class="wrap">
    <div class="filewrap">
      <input type="file" id="fileInput" accept="video/mp4,video/quicktime,video/*">
      <label class="btn" for="fileInput">Choose File</label>
      <span id="fileName" class="file-chip">No file selected</span>
    </div>
    <button id="btnRestart">Restart Video</button>
    <button id="btnPause">Pause Video</button>
    <button id="btnReset" class="ghost">Reset Settings</button>
    <button id="btnCam" class="primary">Camera Mode</button>
    <span class="push"></span>
    <button id="btnSave" class="primary">Save</button>
  </div>
</div>

<!-- status helper BEFORE OpenCV -->
<script>
function setStatus(text){ const el=document.getElementById('status'); if(el) el.textContent=text; else console.log('[status]',text); }
window.__cvReady=false; window.__videoReady=false;
window.Module = {
  onRuntimeInitialized(){ window.__cvReady=true; setStatus('OpenCV.js ready'); if(window.__videoReady && typeof window.__start==='function') window.__start(); }
};
</script>
<script src="https://docs.opencv.org/4.x/opencv.js"></script>

<!-- App -->
<script type="module">
import { Muxer, ArrayBufferTarget } from './libs/mp4-muxer.esm.js';

(() => {
  const $=s=>document.querySelector(s);
  const canvas=$('#canvas'), ctx=canvas.getContext('2d');
  const buf=$('#buf'), bctx=buf.getContext('2d',{willReadFrequently:true});
  const video=$('#video'); video.muted=true; video.playsInline=true;

  // hamburger toggle
  $('#toggleControls').onclick=()=> document.body.classList.toggle('controls-hidden');

  /* Controls */
  const c={
    scale:$('#scale'),minArea:$('#minArea'),thresh:$('#thresh'),morph:$('#morph'),
    alpha:$('#alpha'),maxDisappear:$('#maxDisappear'),maxDist:$('#maxDist'),
    linkDist:$('#linkDist'),trailLen:$('#trailLen'),
    showBoxes:$('#showBoxes'),showTrail:$('#showTrail'),showLinks:$('#showLinks'),showPoints:$('#showPoints'),showText:$('#showText'),
    boxThick:$('#boxThick'), lineWidth:$('#lineWidth'), textSize:$('#textSize'),
    textMode:$('#textMode'), labelText:$('#labelText'),
    boxAlpha:$('#boxAlpha'), lineAlpha:$('#lineAlpha'), textAlpha:$('#textAlpha')
  };
  const b={
    scaleVal:$('#scaleVal'),minAreaVal:$('#minAreaVal'),threshVal:$('#threshVal'),
    morphVal:$('#morphVal'),alphaVal:$('#alphaVal'),maxDisappearVal:$('#maxDisappearVal'),
    maxDistVal:$('#maxDistVal'),linkDistVal:$('#linkDistVal'),trailVal:$('#trailVal'),
    boxThickVal:$('#boxThickVal'), lineWidthVal:$('#lineWidthVal'), textSizeVal:$('#textSizeVal'),
    boxAlphaVal:$('#boxAlphaVal'), lineAlphaVal:$('#lineAlphaVal'), textAlphaVal:$('#textAlphaVal')
  };

  // badges + events
  Object.values(c).forEach(el=>{
    if(el?.type==='range'){
      const id=el.id+'Val'; const badge=b[id] || (el.id==='boxThick'?b.boxThickVal:el.id==='lineWidth'?b.lineWidthVal:el.id==='textSize'?b.textSizeVal:null);
      const upd=()=>{
        if(!badge) return;
        if(el.id.endsWith('Alpha')) badge.textContent = `${el.value}%`;
        else badge.textContent = (el.id==='alpha')?(+el.value/100).toFixed(2):el.value;
      };
      el.addEventListener('input', ()=>{ upd(); if(paused) reprocessPaused(); }); upd?.();
    }else if(el?.type==='checkbox' || el?.tagName==='SELECT'){
      el.addEventListener('change', ()=>{
        if(el===c.textMode){ c.labelText.disabled = (c.textMode.value!=='text'); }
        if(paused) reprocessPaused();
      });
    }else if(el===c.labelText){
      el.addEventListener('input', ()=>{ if(paused) reprocessPaused(); });
    }
  });
  c.scale.addEventListener('change', ()=> start());

  // Colors
  function bindColor(colorEl,hexEl,defHex){
    const norm=s=>{ s=(s||'').trim(); if(!s.startsWith('#')) s='#'+s; return /^#[0-9a-fA-F]{6}$/.test(s)?s.toUpperCase():defHex; };
    colorEl.value=defHex; hexEl.value=defHex;
    colorEl.addEventListener('input', ()=>{ hexEl.value=colorEl.value.toUpperCase(); if(paused) reprocessPaused(); });
    hexEl.addEventListener('change', ()=>{ hexEl.value=norm(hexEl.value); colorEl.value=hexEl.value; if(paused) reprocessPaused(); });
  }
  const colBox=$('#colBox'), hexBox=$('#hexBox'); bindColor(colBox,hexBox,'#FF0000');
  const colLine=$('#colLine'), hexLine=$('#hexLine'); bindColor(colLine,hexLine,'#FF0000');
  const colText=$('#colText'), hexText=$('#hexText'); bindColor(colText,hexText,'#EEEEEE');

  /* Tracker */
  class CentroidTracker{
    constructor(maxDisappeared=25,maxDistance=80){this.next=1;this.objects=new Map();this.disappeared=new Map();this.maxDisappeared=maxDisappeared;this.maxDistance=maxDistance;}
    register(c){this.objects.set(this.next,c);this.disappeared.set(this.next,0);this.next++;}
    deregister(id){this.objects.delete(id);this.disappeared.delete(id);}
    update(cs){
      if(cs.length===0){ for(const id of this.disappeared.keys()){ this.disappeared.set(id,this.disappeared.get(id)+1); if(this.disappeared.get(id)>this.maxDisappeared) this.deregister(id);} return this.objects; }
      if(this.objects.size===0){ cs.forEach(c=>this.register(c)); return this.objects; }
      const ids=[...this.objects.keys()], base=[...this.objects.values()];
      const D=base.map(b=>cs.map(c=>Math.hypot(b[0]-c[0],b[1]-c[1]))), usedR=new Set(), usedC=new Set();
      const rows=[...D.keys()].sort((a,b)=>Math.min(...D[a])-Math.min(...D[b])), argmin=r=>D[r].indexOf(Math.min(...D[r]));
      for(const r of rows){ const ci=argmin(r); if(usedR.has(r)||usedC.has(ci)) continue; if(D[r][ci]>this.maxDistance) continue;
        const id=ids[r]; this.objects.set(id,cs[ci]); this.disappeared.set(id,0); usedR.add(r); usedC.add(ci); }
      for(let ci=0;ci<cs.length;ci++) if(!usedC.has(ci)) this.register(cs[ci]);
      for(let r=0;r<base.length;r++) if(!usedR.has(r)){ const id=ids[r]; this.disappeared.set(id,this.disappeared.get(id)+1); if(this.disappeared.get(id)>this.maxDisappeared) this.deregister(id); }
      return this.objects;
    }
  }
  let tracker=new CentroidTracker(+c.maxDisappear?.value||25,+c.maxDist?.value||80);
  c.maxDisappear?.addEventListener('input',()=>tracker.maxDisappeared=+c.maxDisappear.value);
  c.maxDist?.addEventListener('input',()=>tracker.maxDistance=+c.maxDist.value);

  const trails=new Map();

  /* OpenCV & loop */
  let src=null,gray=null,blur=null,bg=null,diff=null,thr=null,kernel=null,contours=null,hierarchy=null;
  let animId=null, paused=false, procW=0, procH=0, scale=0.6, stream=null;
  let mirrorPreview=false; // mirror overlays when camera on

  let COLOR_RGBA2GRAY = null;
  function initColorConst(){
    COLOR_RGBA2GRAY = (typeof cv.COLOR_RGBA2GRAY === 'number') ? cv.COLOR_RGBA2GRAY : cv.COLOR_RGB2GRAY;
  }

  function cleanup(){
    cancelAnimationFrame(animId); animId=null;
    [src,gray,blur,bg,diff,thr,kernel,contours,hierarchy].forEach(m=>{ try{ m && m.delete(); }catch{} });
    src=gray=blur=bg=diff=thr=kernel=contours=hierarchy=null;
    trails.clear();
  }

  function ensureMats(){
    if(!src || src.cols!==procW || src.rows!==procH){
      src && src.delete(); gray && gray.delete(); blur && blur.delete();
      diff && diff.delete(); thr && thr.delete(); bg && bg.delete();
      src=new cv.Mat(procH,procW,cv.CV_8UC4);
      gray=new cv.Mat(procH,procW,cv.CV_8UC1);
      blur=new cv.Mat(procH,procW,cv.CV_8UC1);
      bg=new cv.Mat(procH,procW,cv.CV_8UC1);
      diff=new cv.Mat(procH,procW,cv.CV_8UC1);
      thr=new cv.Mat(procH,procW,cv.CV_8UC1);
      kernel=cv.getStructuringElement(cv.MORPH_ELLIPSE,new cv.Size(5,5));
      contours=new cv.MatVector(); hierarchy=new cv.Mat();
    }
  }

  function grabToSrc(){
    if(!src) return false;
    bctx.drawImage(video,0,0,procW,procH);           // always grab real orientation
    const im=bctx.getImageData(0,0,procW,procH);
    src.data.set(im.data);
    return true;
  }

  const hexToRGBA=(hex,a)=> {
    hex=hex.replace('#',''); const r=parseInt(hex.slice(0,2),16), g=parseInt(hex.slice(2,4),16), b=parseInt(hex.slice(4,6),16);
    a=Math.max(0,Math.min(1,a)); return `rgba(${r},${g},${b},${a})`;
  };

  function labelString(cx,cy){
    if(!c.showText.checked) return null;
    if(c.textMode.value==='text') return c.labelText.value || '';
    return `${cx.toFixed(2)}, ${cy.toFixed(2)}`;
  }

  function drawOverlayFromDetections(boxes, objs, maxTrail){
    const boxA = (+c.boxAlpha.value)/100;
    const lineA = (+c.lineAlpha.value)/100;
    const textA = (+c.textAlpha.value)/100;

    const strokeBox = hexToRGBA($('#hexBox').value, boxA);
    const strokeLine = hexToRGBA($('#hexLine').value, lineA);
    const fillText  = hexToRGBA($('#hexText').value, textA);

    ctx.globalCompositeOperation='source-over';
    ctx.globalAlpha=1;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    if (mirrorPreview){
      ctx.save(); ctx.translate(canvas.width,0); ctx.scale(-1,1);
      ctx.drawImage(video,0,0,canvas.width,canvas.height);

      if(c.showBoxes.checked){ ctx.lineWidth=+c.boxThick.value; ctx.strokeStyle=strokeBox; boxes.forEach(r=>ctx.strokeRect(r.x,r.y,r.w,r.h)); }
      if(c.showLinks.checked){
        const pts=[...objs.values()].map(([x,y])=>({x,y}));
        const L=+c.linkDist.value; ctx.lineWidth=+c.lineWidth.value; ctx.strokeStyle=strokeLine;
        for(let i=0;i<pts.length;i++) for(let j=i+1;j<pts.length;j++){ const d=Math.hypot(pts[i].x-pts[j].x,pts[i].y-pts[j].y); if(d<=L){ ctx.beginPath(); ctx.moveTo(pts[i].x,pts[i].y); ctx.lineTo(pts[j].x,pts[j].y); ctx.stroke(); } }
      }
      if(c.showTrail.checked && maxTrail>0){
        ctx.lineWidth=Math.max(1,(+c.lineWidth.value-1)); ctx.strokeStyle=strokeLine;
        for(const arr of trails.values()){ if(arr.length<2) continue; ctx.beginPath(); ctx.moveTo(arr[0].x,arr[0].y); for(let k=1;k<arr.length;k++) ctx.lineTo(arr[k].x,arr[k].y); ctx.stroke(); }
      }
      ctx.restore(); // draw text in readable orientation

      ctx.font=`${+c.textSize.value}px Helvetica, Arial, sans-serif`;
      for(const [id,[cx,cy]] of objs.entries()){
        const dx = canvas.width - cx;
        if(c.showPoints.checked){ ctx.beginPath(); ctx.fillStyle=strokeBox; ctx.arc(dx,cy,4,0,Math.PI*2); ctx.fill(); }
        const txt=labelString(cx,cy); if(txt){ ctx.fillStyle=fillText; ctx.fillText(txt,dx+8,cy-8); }
      }
      return;
    }

    // normal
    ctx.drawImage(video,0,0,canvas.width,canvas.height);
    if(c.showBoxes.checked){ ctx.lineWidth=+c.boxThick.value; ctx.strokeStyle=strokeBox; boxes.forEach(r=>ctx.strokeRect(r.x,r.y,r.w,r.h)); }
    if(c.showLinks.checked){
      const pts=[...objs.values()].map(([x,y])=>({x,y}));
      const L=+c.linkDist.value; ctx.lineWidth=+c.lineWidth.value; ctx.strokeStyle=strokeLine;
      for(let i=0;i<pts.length;i++) for(let j=i+1;j<pts.length;j++){ const d=Math.hypot(pts[i].x-pts[j].x,pts[i].y-pts[j].y); if(d<=L){ ctx.beginPath(); ctx.moveTo(pts[i].x,pts[i].y); ctx.lineTo(pts[j].x,pts[j].y); ctx.stroke(); } }
    }
    if(c.showTrail.checked && maxTrail>0){
      ctx.lineWidth=Math.max(1,(+c.lineWidth.value-1)); ctx.strokeStyle=strokeLine;
      for(const arr of trails.values()){ if(arr.length<2) continue; ctx.beginPath(); ctx.moveTo(arr[0].x,arr[0].y); for(let k=1;k<arr.length;k++) ctx.lineTo(arr[k].x,arr[k].y); ctx.stroke(); }
    }
    ctx.font=`${+c.textSize.value}px Helvetica, Arial, sans-serif`;
    for(const [id,[cx,cy]] of objs.entries()){
      if(c.showPoints.checked){ ctx.beginPath(); ctx.fillStyle=strokeBox; ctx.arc(cx,cy,4,0,Math.PI*2); ctx.fill(); }
      const txt=labelString(cx,cy); if(txt){ ctx.fillStyle=fillText; ctx.fillText(txt,cx+8,cy-8); }
    }
  }

  function detectOnCurrentFrame(updateTracker=true){
    cv.absdiff(blur,bg,diff);
    cv.threshold(diff,thr,+c.thresh.value,255,cv.THRESH_BINARY);

    const it=+c.morph.value;
    if(it>0){ cv.morphologyEx(thr,thr,cv.MORPH_OPEN,kernel,new cv.Point(-1,-1),1); cv.dilate(thr,thr,kernel,new cv.Point(-1,-1),it); }

    contours?.delete(); hierarchy?.delete(); contours=new cv.MatVector(); hierarchy=new cv.Mat();
    cv.findContours(thr,contours,hierarchy,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);

    const minArea=+c.minArea.value*scale*scale;
    const boxes=[], centers=[];
    for(let i=0;i<contours.size();i++){
      const cnt=contours.get(i), area=cv.contourArea(cnt); if(area<minArea) continue;
      const r=cv.boundingRect(cnt); const x=r.x/scale, y=r.y/scale, w=r.width/scale, h=r.height/scale;
      boxes.push({x,y,w,h}); centers.push([x+w/2,y+h/2]);
    }

    let objs=new Map();
    if(updateTracker){
      tracker.maxDistance=+c.maxDist.value; tracker.maxDisappeared=+c.maxDisappear.value;
      objs=tracker.update(centers);
      const active=new Set(objs.keys()); for(const id of [...trails.keys()]) if(!active.has(id)) trails.delete(id);
      const maxTrail=+c.trailLen.value;
      for(const [id,[cx,cy]] of objs.entries()){
        if(!trails.has(id)) trails.set(id,[]);
        const arr=trails.get(id); arr.push({x:cx,y:cy}); while(arr.length>maxTrail) arr.shift();
      }
      drawOverlayFromDetections(boxes, objs, maxTrail);
    }else{
      centers.forEach((p,i)=>objs.set(i,p));
      drawOverlayFromDetections(boxes, objs, 0);
    }

    if(!paused){
      const a = Math.min(1,Math.max(0,+c.alpha.value/100));
      cv.addWeighted(bg,(1-a),blur,a,0,bg);
    }
  }

  function reprocessPaused(){
    if(!paused) return;
    ensureMats();
    if(!grabToSrc()) return;
    cv.cvtColor(src,gray,COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray,blur,new cv.Size(5,5),0,0);
    detectOnCurrentFrame(false);
  }

  function start(){
    try{
      cleanup();
      const vw=video.videoWidth||640, vh=video.videoHeight||360;
      canvas.width=vw; canvas.height=vh;
      scale=Math.max(0.3, Math.min(1, +c.scale.value/100));
      procW=Math.max(64, Math.round(vw*scale)); procH=Math.max(36, Math.round(vh*scale));
      buf.width=procW; buf.height=procH;

      ensureMats();
      initColorConst();

      grabToSrc();
      cv.cvtColor(src,gray,COLOR_RGBA2GRAY);
      cv.GaussianBlur(gray,bg,new cv.Size(5,5),0,0);

      setStatus(`Running • ${vw}×${vh} (proc ${procW}×${procH})`);
      paused=false; loop();
    }catch(err){ console.error(err); setStatus('Start failed: '+err.message); }
  }
  window.__start=start;

  function loop(){
    animId=requestAnimationFrame(loop);
    try{
      if(!paused){
        ensureMats();
        if(!grabToSrc()) return;
        cv.cvtColor(src,gray,COLOR_RGBA2GRAY);
        cv.GaussianBlur(gray,blur,new cv.Size(5,5),0,0);
        detectOnCurrentFrame(true);
      }
    }catch(err){ console.error(err); cancelAnimationFrame(animId); animId=null; setStatus('Loop error: '+err.message); }
  }

  /* Sources & UI */
  const fileNameEl = $('#fileName');
  $('#fileInput').addEventListener('change', e=>{
    const f=e.target.files[0]; fileNameEl.textContent = f? f.name : 'No file selected';
    if(!f) return;
    if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    mirrorPreview=false;
    video.srcObject=null;
    video.loop=true; video.onended=()=>{ video.currentTime=0; video.play(); };
    try{ URL.revokeObjectURL(video.src); }catch{}
    video.src=URL.createObjectURL(f); setStatus(`Loading file: ${f.name}`);
  });

  // Camera toggle
  let stream=null;
  $('#btnCam').onclick=async()=>{
    try{
      if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; mirrorPreview=false; video.srcObject=null; setStatus('Camera stopped'); return; }
      const s=await navigator.mediaDevices.getUserMedia({video:{width:1280,height:720},audio:false});
      stream=s; video.loop=false; video.onended=null; video.srcObject=s; mirrorPreview=true;
      await video.play(); setStatus('Camera started (mirrored)');
    }catch(e){ console.error(e); setStatus('Camera failed: '+e.message); }
  };

  $('#btnRestart').onclick=()=>{ if(!window.__videoReady){ setStatus('Load a video or start camera first'); return; } video.currentTime=0; video.play(); start(); };

  const pauseBtn=$('#btnPause');
  $('#btnPause').onclick=()=>{
    if(!window.__videoReady){ setStatus('Load a video or start camera first'); return; }
    paused=!paused;
    if(paused){ video.pause(); setStatus('Paused • tweak sliders to see preview'); pauseBtn.textContent='Resume Video'; reprocessPaused(); }
    else{ video.play(); setStatus(mirrorPreview?'Playing (mirrored)…':'Playing…'); pauseBtn.textContent='Pause Video'; if(animId===null) loop(); }
  };

  $('#btnReset').onclick=()=>{
    const d={scale:60,minArea:1200,thresh:80,morph:2,alpha:5,maxDisappear:25,maxDist:80,linkDist:180,trailLen:20,boxThick:2,lineWidth:2,textSize:14,boxAlpha:100,lineAlpha:100,textAlpha:100};
    for(const [k,v] of Object.entries(d)){
      const el=c[k]; if(!el) continue; el.value=v;
      const badge = b[k+'Val'] || (k==='boxThick'?b.boxThickVal:k==='lineWidth'?b.lineWidthVal:k==='textSize'?b.textSizeVal:k==='boxAlpha'?b.boxAlphaVal:k==='lineAlpha'?b.lineAlphaVal:k==='textAlpha'?b.textAlphaVal:null);
      if(badge){ if(k.endsWith('Alpha')) badge.textContent=v+'%'; else badge.textContent=(k==='alpha')?(v/100).toFixed(2):v; }
    }
    $('#hexBox').value='#FF0000'; $('#colBox').value='#FF0000';
    $('#hexLine').value='#FF0000'; $('#colLine').value='#FF0000';
    $('#hexText').value='#EEEEEE'; $('#colText').value='#EEEEEE';
    c.showBoxes.checked=c.showTrail.checked=c.showLinks.checked=true;
    c.showPoints.checked=false; c.showText.checked=true;
    c.textMode.value='coords'; c.labelText.value='fern'; c.labelText.disabled=true;
    setStatus('Settings reset'); start();
  };

  video.onloadeddata=async()=>{ window.__videoReady=true; try{ await video.play(); }catch{} setStatus('Video ready — starting…'); if(window.__cvReady) start(); };
  video.onplay = ()=> setStatus(mirrorPreview ? 'Playing (mirrored)…' : 'Playing…');
  video.onerror = ()=> setStatus('Video cannot play (codec?)');

  /* -------- Saving (MediaRecorder preferred, WebCodecs fallback) -------- */
  function pickRecorderType(){
    if(!('MediaRecorder' in window) || !canvas.captureStream) return null;
    const candidates=[
      'video/mp4;codecs=avc1.42E01E',
      'video/mp4',
      'video/webm;codecs=vp9',
      'video/webm;codecs=vp8',
      'video/webm'
    ];
    for(const t of candidates){ if(MediaRecorder.isTypeSupported?.(t)) return t; }
    return null;
  }

  async function saveViaMediaRecorder(){
    const fps = await estimateFPS(video) || 30;
    const W=canvas.width, H=canvas.height;
    const mime = pickRecorderType();
    if(!mime) return false;

    const restoreLoop=video.loop, restoreTime=video.currentTime;
    const wasPaused=paused; paused=false; video.loop=false; video.currentTime=0; try{ await video.play(); }catch{}

    const streamCanvas = canvas.captureStream(fps);
    const chunks=[];
    const opts={mimeType:mime, bitsPerSecond: Math.max(600_000, Math.round(W*H*fps*0.12))};
    const rec=new MediaRecorder(streamCanvas,opts);
    rec.ondataavailable=e=>{ if(e.data && e.data.size>0) chunks.push(e.data); };
    const done=new Promise(res=>{ rec.onstop=res; });

    const totalFrames = Number.isFinite(video.duration) ? Math.max(1, Math.round(video.duration*fps)) : null;
    let i=0;
    const tick=()=>{ if(rec.state!=='recording') return; if(video.ended){ rec.stop(); return; }
      if(totalFrames){ const pct=Math.min(100,Math.round(++i/totalFrames*100)); setStatus(`Saving… ${pct}% (${i}/${totalFrames})`); }
      video.requestVideoFrameCallback(()=>tick());
    };

    rec.start(1000);
    tick();
    await done;
    const blob=new Blob(chunks,{type:mime.includes('mp4')?'video/mp4':'video/webm'});
    await saveBlobInteractive(blob, `blob-tracking-${W}x${H}@${fps}.${mime.includes('mp4')?'mp4':'webm'}`);

    video.loop=restoreLoop;
    if(wasPaused){ paused=true; video.pause(); } else { video.play().catch(()=>{}); }
    video.currentTime=restoreTime;
    setStatus('Exported video');
    return true;
  }

  async function saveViaWebCodecs(){
    if (!('VideoEncoder' in window) || !('VideoFrame' in window)) return false;
    const fps = await estimateFPS(video) || 30;
    const W=(canvas.width&~1), H=(canvas.height&~1);

    const restoreLoop=video.loop, restoreTime=video.currentTime;
    const wasPaused=paused; paused=false; video.loop=false; video.currentTime=0; try{ await video.play(); }catch{}

    try{
      const bitrate = Math.max(300_000, Math.round(W*H*fps*0.10));
      const cfgs=[
        {codec:'avc1.640028', width:W, height:H, framerate:fps, bitrate, hardwareAcceleration:'prefer-hardware'},
        {codec:'avc1.4D401F', width:W, height:H, framerate:fps, bitrate, hardwareAcceleration:'prefer-hardware'},
        {codec:'avc1.42E01E', width:W, height:H, framerate:fps, bitrate, hardwareAcceleration:'prefer-hardware'},
      ];
      let cfg=null; for(const c of cfgs){ const sup=await VideoEncoder.isConfigSupported(c).catch(()=>null); if(sup?.supported){ cfg=sup.config; break; } }
      if(!cfg) return false;

      const target=new ArrayBufferTarget();
      const muxer = new Muxer({ target, fastStart:'in-memory', firstTimestampBehavior:'offset', video:{codec:'avc',width:W,height:H,timescale:fps,frameRate:fps}});
      const encCanvas=document.createElement('canvas'); encCanvas.width=W; encCanvas.height=H; const ectx=encCanvas.getContext('2d');

      const encoder=new VideoEncoder({ output:(chunk,meta)=>muxer.addVideoChunk(chunk,meta), error:e=>console.error(e) });
      encoder.configure(cfg);

      const totalFrames = Number.isFinite(video.duration) ? Math.max(1, Math.round(video.duration*fps)) : null;
      let i=0;
      await new Promise(resolve=>{
        const step=()=>{ if(video.ended){ resolve(); return; }
          ectx.drawImage(canvas,0,0,W,H);
          const vf=new VideoFrame(encCanvas,{timestamp:Math.round(i*1e6/fps)}); encoder.encode(vf); vf.close();
          if(totalFrames){ const pct=Math.min(100,Math.round((++i)/totalFrames*100)); setStatus(`Saving… ${pct}% (${i}/${totalFrames})`); }
          video.requestVideoFrameCallback(step);
        };
        video.requestVideoFrameCallback(step);
      });

      await encoder.flush(); muxer.finalize();
      const blob=new Blob([target.buffer],{type:'video/mp4'});
      await saveBlobInteractive(blob, `blob-tracking-${W}x${H}@${fps}.mp4`);
      setStatus('Exported .mp4');
      return true;
    }finally{
      video.loop=restoreLoop;
      if(wasPaused){ paused=true; video.pause(); } else { video.play().catch(()=>{}); }
      video.currentTime=restoreTime;
    }
  }

  async function saveBlobInteractive(blob, suggestedName){
    const canPicker = 'showSaveFilePicker' in window;
    if(canPicker){
      try{
        const handle = await showSaveFilePicker({
          suggestedName,
          types:[{description:'Video File', accept:{[blob.type.includes('mp4')?'video/mp4':'video/webm']:[blob.type.includes('mp4')?'.mp4':'.webm']}}],
        });
        const w = await handle.createWritable(); await w.write(blob); await w.close();
      }catch(e){ /* canceled */ }
    }else{
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download=suggestedName; document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(url),1500);
    }
  }

  document.getElementById('btnSave').addEventListener('click', async ()=>{
    setStatus('Preparing to save…');
    const okRecorder = await saveViaMediaRecorder();
    if(okRecorder) return;
    const okWebCodecs = await saveViaWebCodecs();
    if(okWebCodecs) return;
    setStatus('Saving not supported on this browser.');
  });

  async function estimateFPS(v){
    return new Promise(res=>{
      if(!('requestVideoFrameCallback' in HTMLVideoElement.prototype)) return res(30);
      let f=0,t0=null;
      const cb=(_,meta)=>{ f++; if(t0==null) t0=meta.mediaTime; if(meta.mediaTime-t0>=1){ res(f||30); } else v.requestVideoFrameCallback(cb); };
      v.requestVideoFrameCallback(cb);
    });
  }
})();
</script>
</body>
</html>
