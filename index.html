<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Blob Tracking</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--bg:#121016;--panel:#171320;--canvas:#15121c;--fg:#efe9ff;--muted:#cfc6e6;--line:#2b2240;--accent:#c084fc;--chip:#1a1526}
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--fg);font:16px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
  header{position:sticky;top:0;z-index:5;padding:10px 14px;border-bottom:1px solid var(--line);background:var(--panel)}
  h1{margin:0;font-size:18px}
  #stageWrap{padding:12px 16px 84px}
  #canvas{display:block;margin:0 auto;background:var(--canvas);border:1px solid var(--line);border-radius:12px;max-width:min(1400px,98vw)}
  video,#buf{display:none}
  .controls{padding:10px 16px}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px;align-items:center}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  label{font-size:13px;color:var(--muted)}
  input[type="range"]{width:180px;accent-color:var(--accent)}
  input[type="color"]{width:44px;height:34px;padding:0;border:1px solid var(--line);border-radius:8px;background:var(--chip)}
  input[type="text"].hex{width:96px;padding:8px 10px;border:1px solid var(--line);border-radius:8px;background:var(--chip);color:var(--fg);font-family:ui-monospace,Menlo,Consolas,monospace}
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;border:1px solid var(--line);background:var(--chip);color:var(--muted)}
  .status{margin:8px 0 0;padding:8px 12px;border-radius:10px;font-size:13px;border:1px solid var(--line);background:var(--chip)}
  .bar{position:fixed;left:0;right:0;bottom:0;z-index:6;background:linear-gradient(180deg,rgba(18,16,22,0),rgba(18,16,22,.75)),var(--panel);border-top:1px solid var(--line);padding:10px 16px}
  .bar .wrap{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .push{flex:1}
  button,input[type="file"]{font:inherit;border:1px solid var(--line);background:var(--chip);color:var(--fg);padding:8px 10px;border-radius:10px;cursor:pointer}
  button.primary{border-color:transparent;background:var(--accent);color:#1b1026}
  button.ghost{background:transparent}
</style>
</head>
<body>
<header><h1>Blob Tracking</h1></header>

<div id="stageWrap">
  <canvas id="canvas"></canvas>
  <video id="video" playsinline muted></video>
  <canvas id="buf"></canvas>

  <div class="controls">
    <div class="grid">
      <div class="row"><label>Processing Scale (%) <span id="scaleVal" class="badge">60</span></label><input type="range" id="scale" min="30" max="100" value="60"></div>
      <div class="row"><label>Min Area (px) <span id="minAreaVal" class="badge">1200</span></label><input type="range" id="minArea" min="50" max="30000" value="1200"></div>
      <div class="row"><label>Threshold (0–255) <span id="threshVal" class="badge">200</span></label><input type="range" id="thresh" min="30" max="255" value="200"></div>
      <div class="row"><label>Morph Iterations <span id="morphVal" class="badge">2</span></label><input type="range" id="morph" min="0" max="5" value="2"></div>
      <div class="row"><label>BG Learning Rate α <span id="alphaVal" class="badge">0.05</span></label><input type="range" id="alpha" min="0" max="100" value="5"></div>
      <div class="row"><label>Max Track Disappeared <span id="maxDisappearVal" class="badge">25</span></label><input type="range" id="maxDisappear" min="3" max="150" value="25"></div>
      <div class="row"><label>Max Match Distance (px) <span id="maxDistVal" class="badge">80</span></label><input type="range" id="maxDist" min="10" max="300" value="80"></div>
      <div class="row"><label>Max Link Distance (px) <span id="linkDistVal" class="badge">180</span></label><input type="range" id="linkDist" min="10" max="600" value="180"></div>
      <div class="row"><label>Trail Length (frames) <span id="trailVal" class="badge">20</span></label><input type="range" id="trailLen" min="0" max="200" value="20"></div>
      <div class="row" style="grid-column:1/-1;gap:18px">
        <span class="row"><label>Box</label><input type="color" id="colBox"><input class="hex" id="hexBox" value="#00C2FF"></span>
        <span class="row"><label>Line</label><input type="color" id="colLine"><input class="hex" id="hexLine" value="#9CA3AF"></span>
        <span class="row"><label>Text</label><input type="color" id="colText"><input class="hex" id="hexText" value="#EEEEEE"></span>
      </div>
      <div class="row" style="grid-column:1/-1;gap:18px">
        <label>Show Coords <input type="checkbox" id="showCoord" checked></label>
        <label>Show Trails <input type="checkbox" id="showTrail" checked></label>
        <label>Show Links <input type="checkbox" id="showLinks" checked></label>
        <span id="status" class="status">Loading OpenCV.js…</span>
      </div>
    </div>
  </div>
</div>

<div class="bar">
  <div class="wrap">
    <input type="file" id="fileInput" accept="video/mp4,video/quicktime,video/*">
    <button id="btnCam" class="primary">Camera</button>
    <button id="btnRestart">Restart Video</button>
    <button id="btnPause">Pause</button>
    <button id="btnReset" class="ghost">Reset to Default</button>
    <span class="push"></span>
    <button id="btnSave" class="primary">Save (.mp4)</button>
  </div>
</div>

<script>
function setStatus(text){ const el=document.getElementById('status'); if(el) el.textContent=text; else console.log('[status]',text); }
window.Module = { onRuntimeInitialized(){ window.__cvReady=true; setStatus('OpenCV.js ready'); if(window.__videoReady && typeof window.__start==='function') window.__start(); } };
window.__cvReady=false; window.__videoReady=false;
</script>
<script src="https://docs.opencv.org/4.x/opencv.js"></script>

<script type="module">
import { Muxer, ArrayBufferTarget } from './libs/mp4-muxer.esm.js';

(() => {
  const $=s=>document.querySelector(s);
  const canvas=$('#canvas'), ctx=canvas.getContext('2d');
  const buf=$('#buf'), bctx=buf.getContext('2d',{willReadFrequently:true});
  const video=$('#video'); video.muted=true; video.playsInline=true;

  const c={scale:$('#scale'),minArea:$('#minArea'),thresh:$('#thresh'),morph:$('#morph'),
           alpha:$('#alpha'),maxDisappear:$('#maxDisappear'),maxDist:$('#maxDist'),
           linkDist:$('#linkDist'),trailLen:$('#trailLen'),
           showCoord:$('#showCoord'),showTrail:$('#showTrail'),showLinks:$('#showLinks')};
  const b={scaleVal:$('#scaleVal'),minAreaVal:$('#minAreaVal'),threshVal:$('#threshVal'),
           morphVal:$('#morphVal'),alphaVal:$('#alphaVal'),maxDisappearVal:$('#maxDisappearVal'),
           maxDistVal:$('#maxDistVal'),linkDistVal:$('#linkDistVal'),trailVal:$('#trailVal')};

  // badges + handlers
  Object.entries(c).forEach(([k,el])=>{
    if(el?.type==='range'){
      const id=(k==='trailLen')?'trailVal':(k+'Val'); const badge=b[id];
      const upd=()=>badge.textContent=(k==='alpha')?(+el.value/100).toFixed(2):el.value;
      el.addEventListener('input', ()=>{ upd(); if(paused) reprocessPaused(); }); upd();
    }else if(el?.type==='checkbox'){
      el.addEventListener('change', ()=>{ if(paused) reprocessPaused(); });
    }
  });
  c.scale.addEventListener('change', ()=> start());

  // color pickers
  function bindColor(colorEl,hexEl,defHex){
    const norm=s=>{ s=(s||'').trim(); if(!s.startsWith('#')) s='#'+s; return /^#[0-9a-fA-F]{6}$/.test(s)?s.toUpperCase():defHex; };
    colorEl.value=defHex; hexEl.value=defHex;
    colorEl.addEventListener('input', ()=>{ hexEl.value=colorEl.value.toUpperCase(); if(paused) reprocessPaused(); });
    hexEl.addEventListener('change', ()=>{ hexEl.value=norm(hexEl.value); colorEl.value=hexEl.value; if(paused) reprocessPaused(); });
  }
  const colBox=$('#colBox'), hexBox=$('#hexBox'); bindColor(colBox,hexBox,'#00C2FF');
  const colLine=$('#colLine'), hexLine=$('#hexLine'); bindColor(colLine,hexLine,'#9CA3AF');
  const colText=$('#colText'), hexText=$('#hexText'); bindColor(colText,hexText,'#EEEEEE');

  /* ---------- simple tracker ---------- */
  class CentroidTracker{
    constructor(maxDisappeared=25,maxDistance=80){this.next=1;this.objects=new Map();this.disappeared=new Map();this.maxDisappeared=maxDisappeared;this.maxDistance=maxDistance;}
    register(c){this.objects.set(this.next,c);this.disappeared.set(this.next,0);this.next++;}
    deregister(id){this.objects.delete(id);this.disappeared.delete(id);}
    update(cs){
      if(cs.length===0){for(const id of this.disappeared.keys()){this.disappeared.set(id,this.disappeared.get(id)+1);if(this.disappeared.get(id)>this.maxDisappeared)this.deregister(id);}return this.objects;}
      if(this.objects.size===0){cs.forEach(c=>this.register(c));return this.objects;}
      const ids=[...this.objects.keys()], base=[...this.objects.values()];
      const D=base.map(b=>cs.map(c=>Math.hypot(b[0]-c[0],b[1]-c[1]))), usedR=new Set(), usedC=new Set();
      const rows=[...D.keys()].sort((a,b)=>Math.min(...D[a])-Math.min(...D[b])), argmin=r=>D[r].indexOf(Math.min(...D[r]));
      for(const r of rows){const ci=argmin(r); if(usedR.has(r)||usedC.has(ci)) continue; if(D[r][ci]>this.maxDistance) continue;
        const id=ids[r]; this.objects.set(id,cs[ci]); this.disappeared.set(id,0); usedR.add(r); usedC.add(ci);}
      for(let ci=0;ci<cs.length;ci++) if(!usedC.has(ci)) this.register(cs[ci]);
      for(let r=0;r<base.length;r++) if(!usedR.has(r)){const id=ids[r]; this.disappeared.set(id,this.disappeared.get(id)+1); if(this.disappeared.get(id)>this.maxDisappeared)this.deregister(id);}
      return this.objects;
    }
  }
  let tracker=new CentroidTracker(+c.maxDisappear.value,+c.maxDist.value);
  c.maxDisappear.oninput=()=>tracker.maxDisappeared=+c.maxDisappear.value;
  c.maxDist.oninput=()=>tracker.maxDistance=+c.maxDist.value;
  const trails=new Map();

  /* ---------- OpenCV objects & loop ---------- */
  let src=null,gray=null,blur=null,bg=null,diff=null,thr=null,kernel=null,contours=null,hierarchy=null;
  let animId=null, paused=false, procW=0, procH=0, scale=0.6, stream=null;

  // color conversion constant guard
  let COLOR_RGBA2GRAY = null;
  function initColorConst(){
    COLOR_RGBA2GRAY = (typeof cv.COLOR_RGBA2GRAY === 'number') ? cv.COLOR_RGBA2GRAY : cv.COLOR_RGB2GRAY;
  }

  function cleanup(){
    cancelAnimationFrame(animId); animId=null;
    [src,gray,blur,bg,diff,thr,kernel,contours,hierarchy].forEach(m=>{ try{ m && m.delete(); }catch{} });
    src=gray=blur=bg=diff=thr=kernel=contours=hierarchy=null;
    trails.clear();
  }

  function ensureMats(){
    if(!src || src.cols!==procW || src.rows!==procH){
      src && src.delete(); gray && gray.delete(); blur && blur.delete();
      diff && diff.delete(); thr && thr.delete(); bg && bg.delete();
      src=new cv.Mat(procH,procW,cv.CV_8UC4);
      gray=new cv.Mat(procH,procW,cv.CV_8UC1);
      blur=new cv.Mat(procH,procW,cv.CV_8UC1);
      bg=new cv.Mat(procH,procW,cv.CV_8UC1);
      diff=new cv.Mat(procH,procW,cv.CV_8UC1);
      thr=new cv.Mat(procH,procW,cv.CV_8UC1);
      kernel=cv.getStructuringElement(cv.MORPH_ELLIPSE,new cv.Size(5,5));
      contours=new cv.MatVector(); hierarchy=new cv.Mat();
    }
  }

  function grabToSrc(){
    if(!src) return false;
    bctx.drawImage(video,0,0,procW,procH);
    const im=bctx.getImageData(0,0,procW,procH);
    src.data.set(im.data);
    return true;
  }

  function drawOverlayFromDetections(boxes, objs, maxTrail){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(video,0,0,canvas.width,canvas.height);

    ctx.lineWidth=2; ctx.strokeStyle=hexBox.value;
    boxes.forEach(r=>ctx.strokeRect(r.x,r.y,r.w,r.h));

    if(c.showLinks.checked){
      const pts=[...objs.values()].map(([x,y])=>({x,y}));
      const L=+c.linkDist.value; ctx.lineWidth=1.5; ctx.strokeStyle=hexLine.value;
      for(let i=0;i<pts.length;i++) for(let j=i+1;j<pts.length;j++){
        const d=Math.hypot(pts[i].x-pts[j].x,pts[i].y-pts[j].y);
        if(d<=L){ ctx.beginPath(); ctx.moveTo(pts[i].x,pts[i].y); ctx.lineTo(pts[j].x,pts[j].y); ctx.stroke(); }
      }
    }
    if(c.showTrail.checked && maxTrail>0){
      ctx.lineWidth=1; ctx.strokeStyle=hexLine.value+'90';
      for(const arr of trails.values()){ if(arr.length<2) continue; ctx.beginPath(); ctx.moveTo(arr[0].x,arr[0].y); for(let k=1;k<arr.length;k++) ctx.lineTo(arr[k].x,arr[k].y); ctx.stroke(); }
    }
    ctx.font='14px ui-sans-serif,system-ui';
    for(const [id,[cx,cy]] of objs.entries()){
      ctx.beginPath(); ctx.fillStyle=hexBox.value; ctx.arc(cx,cy,4,0,Math.PI*2); ctx.fill();
      const txt=c.showCoord.checked?`${cx.toFixed(1)}, ${cy.toFixed(1)}`:`ID ${id}`;
      ctx.fillStyle=hexText.value; ctx.fillText(txt,cx+8,cy-8);
    }
  }

  function detectOnCurrentFrame(updateTracker=true){
    cv.absdiff(blur,bg,diff);
    cv.threshold(diff,thr,+c.thresh.value,255,cv.THRESH_BINARY);

    const it=+c.morph.value;
    if(it>0){ cv.morphologyEx(thr,thr,cv.MORPH_OPEN,kernel,new cv.Point(-1,-1),1); cv.dilate(thr,thr,kernel,new cv.Point(-1,-1),it); }

    contours?.delete(); hierarchy?.delete(); contours=new cv.MatVector(); hierarchy=new cv.Mat();
    cv.findContours(thr,contours,hierarchy,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);

    const minArea=+c.minArea.value*scale*scale;
    const boxes=[], centers=[];
    for(let i=0;i<contours.size();i++){
      const cnt=contours.get(i), area=cv.contourArea(cnt); if(area<minArea) continue;
      const r=cv.boundingRect(cnt); const x=r.x/scale, y=r.y/scale, w=r.width/scale, h=r.height/scale;
      boxes.push({x,y,w,h}); centers.push([x+w/2,y+h/2]);
    }

    let objs=new Map();
    if(updateTracker){
      tracker.maxDistance=+c.maxDist.value; tracker.maxDisappeared=+c.maxDisappear.value;
      objs=tracker.update(centers);
      const active=new Set(objs.keys()); for(const id of [...trails.keys()]) if(!active.has(id)) trails.delete(id);
      const maxTrail=+c.trailLen.value;
      for(const [id,[cx,cy]] of objs.entries()){
        if(!trails.has(id)) trails.set(id,[]);
        const arr=trails.get(id); arr.push({x:cx,y:cy}); while(arr.length>maxTrail) arr.shift();
      }
      drawOverlayFromDetections(boxes, objs, maxTrail);
    }else{
      centers.forEach((p,i)=>objs.set(i,p));
      drawOverlayFromDetections(boxes, objs, 0);
    }

    // update background AFTER drawing so paused tweaks show immediately
    cv.addWeighted(bg,(1-+c.alpha.value/100),blur,+c.alpha.value/100,0,bg);
  }

  function reprocessPaused(){
    if(!paused) return;
    ensureMats();
    if(!grabToSrc()) return;
    cv.cvtColor(src,gray,COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray,blur,new cv.Size(5,5),0,0);
    detectOnCurrentFrame(false);
  }

  function start(){
    try{
      cleanup();
      const vw=video.videoWidth||640, vh=video.videoHeight||360;
      canvas.width=vw; canvas.height=vh;
      scale=Math.max(0.3, Math.min(1, +c.scale.value/100));
      procW=Math.max(64, Math.round(vw*scale)); procH=Math.max(36, Math.round(vh*scale));
      buf.width=procW; buf.height=procH;

      ensureMats();
      initColorConst();

      grabToSrc(); cv.cvtColor(src,gray,COLOR_RGBA2GRAY); cv.GaussianBlur(gray,bg,new cv.Size(5,5),0,0);
      setStatus(`Running • ${vw}×${vh} (proc ${procW}×${procH})`);
      paused=false; loop();
    }catch(err){ console.error(err); setStatus('Start failed: '+err.message); }
  }
  window.__start=start;

  function loop(){
    animId=requestAnimationFrame(loop);
    try{
      if(!paused){
        ensureMats();
        if(!grabToSrc()) return;
        cv.cvtColor(src,gray,COLOR_RGBA2GRAY);
        cv.GaussianBlur(gray,blur,new cv.Size(5,5),0,0);
        detectOnCurrentFrame(true);
      }
    }catch(err){ console.error(err); cancelAnimationFrame(animId); animId=null; setStatus('Loop error: '+err.message); }
  }

  /* ------ sources & UI ------ */
  $('#fileInput').onchange=e=>{
    const f=e.target.files[0]; if(!f) return;
    video.loop=true; video.onended=()=>{ video.currentTime=0; video.play(); };
    try{ URL.revokeObjectURL(video.src); }catch{}
    video.src=URL.createObjectURL(f); setStatus(`Loading file: ${f.name}`);
  };
  $('#btnCam').onclick=async()=>{
    try{
      if(stream){ stream.getTracks().forEach(t=>t.stop()); }
      stream=await navigator.mediaDevices.getUserMedia({video:{width:1280,height:720},audio:false});
      video.loop=false; video.onended=null; video.srcObject=stream; await video.play(); setStatus('Camera started');
    }catch(e){ console.error(e); setStatus('Camera failed: '+e.message); }
  };
  $('#btnRestart').onclick=()=>{ if(!window.__videoReady){ setStatus('Load a video or start camera first'); return; } video.currentTime=0; video.play(); start(); };
  $('#btnPause').onclick=()=>{
    if(!window.__videoReady){ setStatus('Load a video or start camera first'); return; }
    paused=!paused;
    if(paused){ video.pause(); setStatus('Paused • tweak sliders to see preview'); $('#btnPause').textContent='Resume'; reprocessPaused(); }
    else{ video.play(); setStatus('Playing…'); $('#btnPause').textContent='Pause'; if(animId===null) loop(); }
  };
  $('#btnReset').onclick=()=>{
    const d={scale:60,minArea:1200,thresh:200,morph:2,alpha:5,maxDisappear:25,maxDist:80,linkDist:180,trailLen:20};
    for(const [k,v] of Object.entries(d)){ c[k].value=v; (k==='alpha'?b.alphaVal:b[(k==='trailLen')?'trailVal':k+'Val']).textContent=(k==='alpha')?(v/100).toFixed(2):v; }
    hexBox.value='#00C2FF'; colBox.value='#00C2FF';
    hexLine.value='#9CA3AF'; colLine.value='#9CA3AF';
    hexText.value='#EEEEEE'; colText.value='#EEEEEE';
    c.showCoord.checked=c.showTrail.checked=c.showLinks.checked=true;
    start();
  };
  video.onloadeddata=async()=>{ window.__videoReady=true; try{ await video.play(); }catch{} setStatus('Video ready — starting…'); if(window.__cvReady) start(); };
  video.onplay = ()=> setStatus('Playing…');
  video.onerror = ()=> setStatus('Video cannot play (codec?)');

  /* -------- Save (ALWAYS WORKS: prefers MediaRecorder) -------- */
  $('#btnSave').onclick = () => saveMP4().catch(e=>{ console.error(e); setStatus('Save failed: '+e.message); });

  function supportsWebCodecs(){ return 'VideoEncoder' in window && 'VideoFrame' in window; }
  function supportsMediaRecorder(){ return 'MediaRecorder' in window && typeof canvas.captureStream==='function'; }

  async function saveMP4(){
    if(!video.src || stream){
      setStatus('Load a video file first — export from live camera is not supported'); return;
    }
    // Prefer MediaRecorder (works on iOS + desktop, real-time, never hangs)
    if (supportsMediaRecorder()) { await saveViaMediaRecorder(); return; }
    // Fallback: WebCodecs + muxer
    if (supportsWebCodecs()) { await saveViaWebCodecsDeterministic(); return; }
    setStatus('Export is not supported in this browser.');
  }

  async function saveViaMediaRecorder(){
    await ensureMeta(video);
    const fps = 30; // canvas stream rate
    const stream = canvas.captureStream(fps);
    // pick a mime that works (iOS Safari prefers MP4)
    const preferred = [
      'video/mp4;codecs=avc1.42E01E',
      'video/mp4',
      'video/webm;codecs=vp9',
      'video/webm;codecs=vp8'
    ];
    let mime = preferred.find(t => MediaRecorder.isTypeSupported?.(t)) || '';
    const rec = new MediaRecorder(stream, { mimeType: mime || undefined, videoBitsPerSecond: 4_000_000 });
    const chunks=[]; rec.ondataavailable=e=>{ if(e.data && e.data.size) chunks.push(e.data); };
    const done=new Promise(r=>rec.onstop=r);

    // progress UI
    const dur = isFinite(video.duration)? video.duration : 0;
    const prog = setInterval(()=>{ if(dur>0) setStatus(`Saving (recording)… ${Math.min(100, Math.round(100*video.currentTime/dur))}%`); }, 250);

    // start from beginning, play once
    const wasPaused = paused;
    paused = false;
    await seekAsync(video, 0);
    rec.start(100); // gather data frequently
    try{ await video.play(); }catch{}
    await new Promise(r=>video.addEventListener('ended', r, {once:true}));
    rec.stop(); await done;
    clearInterval(prog);
    if (wasPaused) { paused = true; video.pause(); }

    const type = (mime && mime.includes('mp4')) ? 'video/mp4' : 'video/webm';
    const blob = new Blob(chunks, { type });
    await saveBlobInteractive(blob, 'blob-tracking.mp4');
    setStatus('Exported .mp4');
  }

  // deterministic fallback (desktop) – if MR is missing
  async function saveViaWebCodecsDeterministic(){
    const fps = await estimateFPS(video) || 30;
    await ensureMeta(video);
    const duration = Math.max(0, video.duration || 0);
    let frames = Math.max(1, Math.round(duration*fps));

    // even dimensions + clamp to safe H.264 area
    const W0=(canvas.width&~1), H0=(canvas.height&~1);
    const MAX=414720; const s = (W0*H0>MAX)? Math.sqrt(MAX/(W0*H0)) : 1;
    const W = (Math.floor(W0*s)&~1), H = (Math.floor(H0*s)&~1);

    const encCanvas=document.createElement('canvas'); encCanvas.width=W; encCanvas.height=H;
    const ectx=encCanvas.getContext('2d');

    const cfgs = [
      {codec:'avc1.640028',width:W,height:H,framerate:fps,hardwareAcceleration:'prefer-hardware',bitrate:Math.round(W*H*fps*0.12)},
      {codec:'avc1.4D4020',width:W,height:H,framerate:fps,hardwareAcceleration:'prefer-hardware',bitrate:Math.round(W*H*fps*0.12)},
      {codec:'avc1.42E01E',width:W,height:H,framerate:fps,hardwareAcceleration:'prefer-hardware',bitrate:Math.round(W*H*fps*0.12)},
    ];
    let ok=null; for(const cfg of cfgs){ const sup=await VideoEncoder.isConfigSupported(cfg).catch(()=>null); if(sup?.supported){ ok=sup.config; break; } }
    if(!ok){ setStatus('Encoder not supported for this size. Lower “Processing Scale”.'); return; }

    const target=new ArrayBufferTarget();
    const muxer=new Muxer({ target, fastStart:'in-memory', firstTimestampBehavior:'offset',
      video:{ codec:'avc', width:W, height:H, timescale:fps, frameRate:fps } });

    let encoded=0;
    const encoder=new VideoEncoder({
      output:(chunk,meta)=>{
        const ts=Math.round(encoded*1e6/fps);
        muxer.addVideoChunk(chunk,meta,ts,Math.round(1e6/fps),0);
        encoded++;
        if (encoded%10===0 || encoded===frames) setStatus(`Saving… ${Math.round(100*encoded/frames)}%`);
      },
      error:e=>console.error(e)
    });
    encoder.configure(ok);

    // encode by seeking frame-by-frame (no rVFC)
    for(let i=0;i<frames;i++){
      const t = Math.min(duration, i/fps);
      await seekAsync(video, t);
      ensureMats(); if(!grabToSrc()) break;
      cv.cvtColor(src,gray,COLOR_RGBA2GRAY);
      cv.GaussianBlur(gray,blur,new cv.Size(5,5),0,0);
      detectOnCurrentFrame(true);

      ectx.drawImage(canvas,0,0,W,H);
      const vf=new VideoFrame(encCanvas,{timestamp:0});
      encoder.encode(vf); vf.close();
      if (i%5===0) await new Promise(r=>setTimeout(r,0));
    }

    await encoder.flush(); encoder.close();
    if (encoded===0){ setStatus('No frames encoded (file not seekable). Use the default Save (MediaRecorder) mode.'); return; }
    muxer.finalize();

    const blob=new Blob([target.buffer],{type:'video/mp4'});
    await saveBlobInteractive(blob, `blob-tracking-${W}x${H}@${fps}.mp4`);
    setStatus('Exported .mp4');
  }

  // save to local (file picker on desktop, Share on iOS/macOS Safari; else a download)
  async function saveBlobInteractive(blob, suggestedName){
    if (navigator.canShare) {
      try{
        const file=new File([blob], suggestedName, {type:blob.type||'video/mp4'});
        if (navigator.canShare({files:[file]})) { await navigator.share({files:[file],title:'Exported video'}); return; }
      }catch{}
    }
    if ('showSaveFilePicker' in window){
      const handle=await showSaveFilePicker({
        suggestedName,
        types:[{description:'MP4 Video', accept:{'video/mp4':['.mp4']}}],
      });
      const w=await handle.createWritable(); await w.write(blob); await w.close(); return;
    }
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download=suggestedName; a.target='_blank';
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url),1500);
  }

  /* Helpers */
  function ensureMeta(v){ if(isFinite(v.duration)&&v.duration>0) return Promise.resolve(); return new Promise(r=>v.addEventListener('loadedmetadata',r,{once:true})); }
  function seekAsync(v,t){ return new Promise(r=>{ const h=()=>{v.removeEventListener('seeked',h); r();}; v.addEventListener('seeked',h); v.currentTime=t; }); }
  async function estimateFPS(v){
    if(!('requestVideoFrameCallback' in HTMLVideoElement.prototype)) return 30;
    return new Promise(res=>{
      let f=0,t0=null; const cb=(_,m)=>{ f++; if(t0==null) t0=m.mediaTime; if(m.mediaTime-t0>=1){ res(Math.max(24,Math.min(60,f))); }else v.requestVideoFrameCallback(cb); };
      v.requestVideoFrameCallback(cb);
    });
  }

  // Wire window flags for OpenCV bootstrap
  window.__videoReady=false;
  video.onloadeddata = async ()=>{ window.__videoReady=true; try{ await video.play(); }catch{} setStatus('Video ready — starting…'); if(window.__cvReady) start(); };

  // Color inputs (need after DOM ready)
  const hexBox=$('#hexBox'), hexLine=$('#hexLine'), hexText=$('#hexText');
})();
</script>
</body>
</html>
